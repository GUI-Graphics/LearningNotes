# Chapter2 什么是Unix?什么是Linux

可以使用LiveCD运行Unix系统,但是除非特别分区,不能在LiveCD上保存文件.LiveCD会划分一部分内存当做虚拟磁盘,因此会降低性能.不过使用LiveCD体验不同版本的Unix系统是个好方法.可以将系统安装到USB上,这样就能在系统上保存文件了.

# Chapter3 Unix连接

有两个抽象的概念:*终端(Terminal)*和*主机*,终端负责输入输出,主机负责响应,因此可以抽象的给出以下公式:

计算机=终端+主机<br>
终端=输入设施+输出设施

终端和主机分离是很重要的思想,这意味着多用户可以同时使用一个Unix系统,只要他有一个终端.

终端和主机可以任意远,前提是两者必须有一个连接.甚至可以使用硬件仿真终端,连接到主机.比如在你的电脑上打开四个Shell,连接到四个不同的Unix主机上.

有个特殊的终端,称为*控制台*,只有系统管理员能接触到控制台.比如当系统出现问题时,会向控制台打印消息,其他终端则不可见.

## 3.1 无头系统(headless system)

有很多没有连接终端的主机,比如Web服务器,路由,这些机器不需要人类的直接输入.当这些机器出现问题时,管理员可以建立一个连接,修复问题,断开连接,让系统自主工作.

# Chapter4 开始使用Unix

注销登录的几种方式:

* 可以使用Ctrl-D组合键向主机发送一个信号,表明不会再有输入了,这样Shell就会终止,Unix将您注销.

* end-of-file信号还有其他作用,因此Ctrl-D可能会不经意间将您注销.这时可以通过logout和exit命令进行注销.

## passwd命令
当您登录进系统后,可以通过passwd命令更改口令

## last命令
last命令用于显示用户登录信息,可以带一个用户标识参数,打印该用户最近的登录信息.不带参数的last命令打印所有用户的登录信息.

## 超级用户root
管理员拥有特殊权限,超级权限很容易对系统造成损害,大多数时间管理员使用正常用户标识进行常规工作,只有在进行需要特殊权限的操作时才切换到超级用户.

# Chapter6 Unix工作环境

典型的Linux启动级别

运行级别 | 描述
--------|----
0|关机
1|单用户模式(命令行)
2|非标准化
3|多用户模式(命令行)
4|非标准化
5|多用户模式:GUI
6|重新启动

默认情况下,Linux默认引导至启动级别3或5.级别1是旧时代的延续,当切换到启动级别1时,系统首先会告知所有用户系统即将关闭,然后重启Unix到运行级别1,即所谓的维护模式,现在称为单用户模式.这时管理员知道系统没有其他用户,就可以进行一些工作了.
现在的Linux系统已经非常灵活了,管理员可以在其他用户登录的情况下完成大量工作,只有在非常严重的情况下才需要将系统引导至启动级别1.

## 6.9 控制焦点:任务切换
Alt-Tab / Alt-Shift-Tab 切换活跃窗口

## 6.10 多桌面/工作空间
Ctrl-Alt-方向键,切换工作空间

## 6.12 虚拟控制台
Linux默认开机为用户打开七个终端,前6个是字符终端,第7个是图形终端.可以使用Alt+F1~7在不同终端切换,不过当处在图形终端时Alt+F1~7通常有其他用户,因此要加上Ctrl键才能切换终端.打开多个终端的好处有,当图形终端垮掉时,可以切换到字符终端解决问题.

## 6.15 复制粘贴
* 剪贴板是一个看不见的存储区
* 复制将源复制到存储区
* 剪切将源复制到存储区的同时,删除源

剪切和复制都会覆盖剪贴板,粘贴时,剪贴板的内容保持不变.

## 6.16 以超级用户工作: su
可以在启动时以超级用户登录,或者使用su命令切换到超级用户. su命令允许临时切换用户标识,只需在命令后面加上用户标识. 可以加上连字符-,切换用户标识的同时切换工作目录,如```su - gui```.

## 6.17 以超级用户执行单独的一条命令: sudo
登录超级用户是一件危险的事情,避免危险的最好方法就是使用sudo.sudo命令允许您以另一个用户标识执行一条单独的命令,默认的用户标识是root.

## 6.20 关机与重启
修改运行级别的命令是init,想重启输入:sudo init 6,想关机输入:sudo init 0. init命令不是专门用来关机或重启的,通常使用reboot命令:
sudo reboot
系统将会切换到运行级别6,即重启.或者使用shutdown进行关机,最简单的shutdown命令:
sudo shutdown now

# Chapter7 Unix键盘

信号名 | 含义 | 快捷键
------| ----| ----
erase  | 删除一个字符 | ^H
werase | 删除一个单词 | ^W
kill | 删除一行 | ^U
flush | 清空缓存 | ^O
eof | 文件末尾 | ^D
intr | 中断 | ^C
quit | 退出 | ^\

# Chapter8 能够立即使用的命令

可以使用whereis查找命令的位置，如果是内置命令，则要使用type显示命令的信息。

这章的命令不实用，使用bc命令还不如使用nodejs

# Chapter9 文档资料：Unix手册与Info

推荐使用的man手册命令

命令|  |
---| ---
RETURN | 向下一行
鼠标滚轮 | 上下移动行
SPACE | 向下一页
b | 向上一页
g | 移到顶部
G | 移到末尾
/pattern | 向下搜索
n | 向下搜索
N | 向上搜索

*在man页输入！就可以敲击命令, 比如！pwd，在浏览的过程中查看当前目录*

## 9.8 Unix手册的组织方式

1. 命令
2. 系统调用
3. 库函数
4. 特殊文件
5. 文件格式
6. 游戏
7. 杂项
8. 系统管理

在我的Ubuntu系统中man手册存在/usr/share/man文件夹，每一节存在单独的一个子文件夹中，比如what(1)命令的手册文件名是whatis.1.gz，存在man1文件夹中，read(2)系统调用的手册文件名是read.2.gz，存在man2文件夹。默认情况下man会在所有的子文件下查找手册文件，并显示找到的第一个手册文件。

可以使用-f选项显示简略的信息，-f将查找整个手册，找到所有的手册文件，并显示手册的Name信息。也可以使用更快捷的*wathis*命令，如下所示

```
gui@hp:~$ man -f kill
kill (2)             - send signal to a process
kill (1)             - send a signal to a process
gui@hp:~$ whatis kill
kill (2)             - send signal to a process
kill (1)             - send a signal to a process
```

可以使用-k选项搜索关键字，man将在所有手册文件的Name节，也可以使用apropos命令，效果是一样的。

# 9.14 foo, bar和foobar
foo，bar，foobar在Unix文化中通常用来引用一个没有名字的东西。

# Chapter12 使用Shell变量和选项

只有全局变量才能被子进程继承，可以使用export命令将本地变量添加到父进程的全局变量列表中，这样就能被子进程继承。可以通过环境变量向子进程传递消息，但是子进程没有办法通过环境变量给父进程反馈消息。

Shell有一些选项可以控制它的行为，可以使用set命令操纵这些选项。set -o ignoreeof表示shell将忽略^D，set +o ignoreeof则不忽略^D。

可以使用env查看*进程*的所有全局变量，set查看shell的所有变量。


# Chapter13 实用Shell： 命令和定制

除了字母和数字外很多字符在Unix中有特殊含义，称为元字符。有三种方法可以让Shell忽略元字符的特殊含义：
1. ""
2. ''
3.  \
这三种方法会使得Shell从注意元字符的模式切换到不注意元字符的模式。

## 13.4 内置命令

type可以查看命令是否是内置命令，关键字还是外部命令。
Unix手册没有内部命令的帮助信息，可以实用help内部命令查看内部命令的帮助信息。

## 13.14 命令替换
可以实用 \` 字符进行命令替换

## 13.16 历史列表
可以实用fc -l或者history查看历史命令列表。
* ！！ 重复上一条命令
* ！number 重复第几条命令
* ！number:s/pattern/replacement/ 重复第几条命令并做出修改

如果是重复上一条命令，还可以用<br>
^patter^replacement

## 13.24 alias, unalias

alias [name=commands]，可以使用\\临时挂起别名

# Chapter14 实用Shell：初始化文件

有几个初始化文件：环境文件，登录文件，注销文件，在我的Ubuntu系统中分别对应：.bashrc，.profile，.bash_logout。非登录Shell执行环境文件，登录shell还会执行登录文件。

虚拟终端，虚拟终端打开的子Shell都是未登录Shell，可以实用login命令进行登录，变成登录Shell。ssh必须登录，所以是登录shell。

# Chapter16 过滤器：简介和基本操作

管道线：*tee*<br>
tee [-a] file...

*cat*:<br>
cat [-bns] [file...]

-n 每行插入行号
-b 和-n一起使用，不对空行编号
-s 挤压多个空行成一行

划分文件：split
split [-d] [-a num] [-l lines] [file [prefix]]
split将文件按行拆分成若干个小的文件。
-l 指示每个文件多少行
-d 默认文件以小写字母加上前缀（默认为x）命名，比如xaa,xab,xac...。
prefix制定前缀。

翻转：tac<br>
tac [file...]<br>
tac命令组合前先将文件翻转。

rev [file...]<br>
将每行翻转

colrm [startcol [endcol]]

# Chapter17 过滤器：比较和抽取

cmp file1 file2<br>
比较任意两个文件

comm [-123] file1 file2<br>
比较两个有序的文本文件，第一列输出第一个文件独有的，第二列输出第二个文件独有的，第三个输出公共的。-123，表示抑制输出。

比较无序文件：diff<br>
默认给出简略信息，可以实用-u选项给出上下文，还可以控制上下文的行数，这时用-U，比如-U5显示5行的上下文信息。-y选项并排显示。

抽取数据列：cut<br>
cut -c list [file...]
和colrm相反，cut抽取某些列，列由list指定，可以有多个列，中间用逗号隔开，不能有空格，比如：
```
1,8,10
1,8,10-15
```
都是合理的。如果不想按列抽取，则可以按分隔符抽取，语法如下：<br>
cut -f list [-d delimiter] [-s] [file...]<br>
其中-s表示suppress，当一行没有遇到定界符时，默认会输出这一行，可以用-s选项忽略这一行。

组合数据列：paste<br>
paste [-d char...] [file...]<br>
假定每个文件包含一列，paste将会把文件用分隔符组合成一个文件，默认的分隔符是tab，Unix中tab是8个空格。

创建行号：nl<br>
nl [-v start] [-i increment] [-b a] [file...]<br>

nl默认忽略空行，要对空行记录行数需要加上-b a，选项。

统计命令：wc<br>
wc [-clLw] [file...]<br>
wc 统计行数，单词数和字符数，如果指定不止一个文件，则还会输出一行总的统计信息。如果不想显示所有信息，可以用-c,-l,-w制定想要看的信息。-L则显示最长行的字符数。

expand [-i] [-t size | -t list] [file...]<br>
将tab扩展成空格，默认是8个空格，也可以用-t制定，如果只想扩展行头的tab，使用-i。

# Chapter19 过滤器
grep抽取包含特定模式的行。<br>
grep [-cilLnrsvwx] pattern [file...]<br>
grep 默认输出所有符合特定模式的行，使用-c选项则输出总的行数，例如：<br>
ls -F /etc | grep -c '/'<br>
将输出etc目录下的子目录数。<br>
grep对大小写敏感，可以用-i选项忽略大小写。<br>
如果想得到筛选的行在源的位置，使用-n，选项。<br>
当不止一个文件时，可以使用-l(list filename)，输出包含模式的文件。<br>
-w，只搜索完整的单词。<br>
-v，选取不包含模式的行。<br>
-r，对目录下的所有文件，包括子目录下的文件进行过滤。<br>
-s，如果对文件没有权限会报告错误，可以使用-s选项抑制错误输出。

sort<br>
sort [-dfnru] [-o outfile] [infile...]<br>
-d(dictionary)只查看数字，字母和空白符，当包含妨碍排序的字符时，可以使用这个选项。<br>
-f(fold)忽略大小写。<br>
-n，识别行开头的数字，按数字排序。<br>
-r，返乡排序。<br>
-c，检查是否有序。<br>
-u，合并向同行，只留一行。<br>
-o，暂存排序结果，将结果输出到文件

## 更改排序标准
export LC_COLLATE=C
export LC_COLLATE=POSIX

## 19.2 查找重复行：uniq
uniq [-cdu] [infile [outfile]]<br>
uniq处理有序数据，默认删除重复行然后输出<br>
-d，只查看重复行<br>
-u，只查看唯一行<br>
-c，统计重复次数。

## 合并有序数据：join
join [-i] [-a1|-v1] [-a2|-v2] [-1 field1] [-2 field2] file1 file2<br>
jion需要按照字符关键字排序。<br>
* -i，忽略大小写
* -a1，外连接，不论匹配与否将一中的所有条目输出
* -v1，输出1中不匹配的条目

## 转换字符：tr
tr [-cds] set1 [set2]<br>
tr将集合1中的字符转换成集合2中的字符，注意：<br>
tr abcd Ax<br>
tr abcd Axxx<br>
意思是一样的，都是将a变成A，bcd变成x，还可以实用正则表达式制定集合如：<br>
tr [:upper:] [:lower:]<br>
-c选项制定不在set1中的字符转换成set2中的字符。<br>
-s选项将连续的集合1中的字符压缩成单字符。
