## Chapter 3 System Programming Concepts

### 系统调用过程

1. 应用程序通过包装函数调用系统调用.
2. 包装函数需要把所有的参数传给一个陷阱处理例程.这些参数通过栈传递给包装函数,而内核要求这些参数在特定的寄存器上.包装函数会把参数复制到这些寄存器上.
3. 因为内核处理系统调用的方式是一样的,内核需要一种方法标志系统调用. 因此包装函数会把系统调用号(system call number)复制到%eax寄存器上.
4. 包装函数会执行一个trap指令(int 0x80),这会导致处理器从用户态转到内核态,并执行陷阱处理向量0x80位置上的代码.
5. 0x80位置上的代码调用system_call()例程来处理陷阱.该处理函数:
	1. 保存寄存器到内核栈中
	2. 检查系统调用号
	3. 通过系统调用号以及系统调用表,找到相应的系统调用服务例程并调用.如果服务例程有参数则对参数进行检查,例程最终会返回一个执行状态给system_call例程.
	4. 从内核栈中恢复寄存器,并把系统调用返回值放到栈中.
	5. 返回到包装函数,同时从内核态返回到用户态.
6. 如果系统调服务例程用返回值表明了一个错误,包装函数会据此设置全局变量errno,同时返回一个整数表明系统调用执行成功还是失败.

*成功的系统调用不会将errno置零*,所以错误提示有可能是之前的系统调用导致的,因此必须在检查errno之前先检查系统调用返回值是否表明发生了错误.有些系统函数在执行成功后也会返回-1,因此要检查这些系统调用是否执行成功需要将errno置零,只有当返回值等于-1,errno非零才表明发生了错误.

#### 错误处理函数
perror()先打印msg,紧接着打印当前errno对应的信息.
``` c
#include <stdio.h>
void perror(const char* msg);
```
``` c
fd = open(pathname, flags, mode);
if(fd == -1) {
	perror("open");
	exit(EXIT_FAILURE);
}
```
strerror()返回errnum对应的错误信息
``` c
#include <string.h>
char* strerror(int errnum);
```
返回的字符信息有可能是静态分配的,可能被之后的strerror覆盖.对于不识别的错误号,strerror会返回字符串Unknown error nnn,一些实现也可能返回NULL.
